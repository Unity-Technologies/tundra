#include "DynamicOutputDirectories.hpp"
#include "MemAllocHeap.hpp"
#include "MemAllocLinear.hpp"
#include "FileInfo.hpp"
#include "BinaryData.hpp"
#include "RuntimeNode.hpp"

//This entire file's sole purpose is to provide some runtime storage capabilties for storing which files were generated by nodes as they were executed.
//We want to make sure we record the generated files immediately after the node with a targetdirectory ran, but we can only write this information to disk
//when the build finishes.  This file provides for a per thread allocator that gets used to store directory listings in, that will persist until we have
//written the AllBuiltNodes structure to disk

struct State
{
    MemAllocHeap m_Heap;
    int workerThreadCount;
    MemAllocLinear* m_PerThreadLinearAllocators;
};

static State s_State;

const int kDynamicOutputDirectoryThreadSize = MB(0.25);

void InitializeDynamicOutputDirectories(int workerThreadCount)
{
    s_State.workerThreadCount = workerThreadCount;
    HeapInit(&s_State.m_Heap);

    s_State.m_PerThreadLinearAllocators = HeapAllocateArray<MemAllocLinear>(&s_State.m_Heap, workerThreadCount);
    for (int i = 0; i < workerThreadCount; ++i)
    {
        LinearAllocInit(&s_State.m_PerThreadLinearAllocators[i], &s_State.m_Heap, kDynamicOutputDirectoryThreadSize, "dynamicOutputDirectories");
    }
}

struct Context
{
    const char* m_BasePath;
    size_t m_BasePathLength;
    SinglyLinkedPathList* m_List;
    MemAllocLinear* m_Allocator;

    Context(const char* basePath, MemAllocLinear* allocator, SinglyLinkedPathList* list)
    {
        m_BasePath = basePath;
        m_BasePathLength = strlen(m_BasePath);
        m_Allocator = allocator;
        m_List = list;
    }

    static void Callback(void* ctx, const FileInfo& fileInfo, const char* path)
    {
        Context& context = *(Context*)ctx;
        SinglyLinkedPathList& result = *context.m_List;

        size_t pathLength = strlen(path);

        char* copiedPath = LinearAllocateArray<char>(context.m_Allocator, context.m_BasePathLength + 2 + pathLength);
        memcpy(copiedPath, context.m_BasePath, context.m_BasePathLength);
        copiedPath[context.m_BasePathLength] = '/';
        memcpy(copiedPath + context.m_BasePathLength + 1, path, pathLength);
        copiedPath[context.m_BasePathLength + pathLength + 1] = 0;

        SinglyLinkedPathListEntry* newEntry = LinearAllocate<SinglyLinkedPathListEntry>(context.m_Allocator);
        newEntry->next = result.head;
        newEntry->path = copiedPath;
        result.head = newEntry;
        result.count++;
    }
};

SinglyLinkedPathList* AllocateEmptyPathList(int threadIndex)
{
    auto result = LinearAllocate<SinglyLinkedPathList>(&s_State.m_PerThreadLinearAllocators[threadIndex]);
    result->head = nullptr;
    result->count = 0;
    return result;
}

void AppendDirectoryListingToList(const char* directoryToList, int threadIndex, SinglyLinkedPathList& appendToList)
{
    Context ctx(directoryToList, &s_State.m_PerThreadLinearAllocators[threadIndex], &appendToList);
    ListDirectory(directoryToList, "*", true, &ctx, Context::Callback);
}

void DestroyDynamicOutputDirectories()
{
    for (int i = 0; i < s_State.workerThreadCount; ++i)
        LinearAllocDestroy(&s_State.m_PerThreadLinearAllocators[i]);

    HeapFree(&s_State.m_Heap, s_State.m_PerThreadLinearAllocators);
    HeapDestroy(&s_State.m_Heap);
}
